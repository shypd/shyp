import { writeFile, readFile, symlink, unlink } from 'fs/promises'
import { existsSync } from 'fs'
import { join } from 'path'
import { execa } from 'execa'
import type { AppConfig, EngineConfig, ModuleConfig } from '../schemas/index.js'
import { NGINX_AVAILABLE, NGINX_ENABLED } from '../utils/paths.js'

// Generate nginx config for a proxy app
export function generateProxyConfig(config: AppConfig): string {
  const domain = config.domain
  const port = config.port
  const nginx = config.nginx || {}

  const aliases = config.aliases?.length
    ? ' ' + config.aliases.join(' ')
    : ''

  const clientMaxBody = nginx.client_max_body_size || '10M'
  const readTimeout = nginx.proxy_read_timeout || 60
  const sendTimeout = nginx.proxy_send_timeout || 60

  let websocketConfig = ''
  if (nginx.websocket_path) {
    websocketConfig = `
    # WebSocket support
    location ${nginx.websocket_path} {
        proxy_pass http://127.0.0.1:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_read_timeout 86400;
        proxy_send_timeout 86400;
    }
`
  }

  return `# Generated by Shyp - ${config.name}
# Do not edit manually

server {
    listen 80;
    listen [::]:80;
    server_name ${domain}${aliases};

    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${domain}${aliases};

    ssl_certificate /etc/letsencrypt/live/${domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${domain}/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    client_max_body_size ${clientMaxBody};

    # Proxy to Node.js app
    location / {
        proxy_pass http://127.0.0.1:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_read_timeout ${readTimeout};
        proxy_send_timeout ${sendTimeout};
    }
${websocketConfig}
    # Cache Next.js static assets
    location /_next/static {
        proxy_pass http://127.0.0.1:${port};
        proxy_cache_valid 200 60m;
        add_header Cache-Control "public, max-age=31536000, immutable";
    }

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/json application/javascript image/svg+xml;

    access_log /var/log/nginx/${config.name}-access.log;
    error_log /var/log/nginx/${config.name}-error.log;
}
`
}

// Generate nginx config for a static site
export function generateStaticConfig(config: AppConfig): string {
  const domain = config.domain
  const root = config.path
  const nginx = config.nginx || {}

  const aliases = config.aliases?.length
    ? ' ' + config.aliases.join(' ')
    : ''

  // For Next.js static exports, serve from /out
  const staticRoot = config.type === 'nextjs' ? `${root}/out` : root

  return `# Generated by Shyp - ${config.name} (static)
# Do not edit manually

server {
    listen 80;
    listen [::]:80;
    server_name ${domain}${aliases};

    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${domain}${aliases};

    ssl_certificate /etc/letsencrypt/live/${domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${domain}/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    root ${staticRoot};
    index index.html;

    # Handle routing (SPA/Next.js static export)
    location / {
        try_files $uri $uri/ $uri.html /index.html;
    }

    # Cache Next.js static assets aggressively
    location /_next/static {
        expires 1y;
        add_header Cache-Control "public, max-age=31536000, immutable";
    }

    # Cache public assets
    location /assets {
        expires 1M;
        add_header Cache-Control "public, max-age=2592000";
    }

    # Cache other static files
    location ~* \\.(ico|css|js|gif|jpeg|jpg|png|woff|woff2|ttf|svg|eot|webp)$ {
        expires 1M;
        add_header Cache-Control "public, max-age=2592000";
    }

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/json application/javascript image/svg+xml;

    access_log /var/log/nginx/${config.name}-access.log;
    error_log /var/log/nginx/${config.name}-error.log;
}
`
}

// Generate nginx config for an engine module
export function generateModuleConfig(
  engine: EngineConfig,
  moduleName: string,
  moduleConfig: ModuleConfig
): string {
  const domain = moduleConfig.domain
  const port = moduleConfig.port
  const nginx = moduleConfig.nginx || {}

  const aliases = moduleConfig.aliases?.length
    ? ' ' + moduleConfig.aliases.join(' ')
    : ''

  // Shared engine services (WebSocket, API)
  let sharedServices = ''
  if (nginx.websocket_path && nginx.websocket_port) {
    sharedServices += `
    # Engine WebSocket (shared)
    location ${nginx.websocket_path} {
        proxy_pass http://127.0.0.1:${nginx.websocket_port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_read_timeout 86400;
        proxy_send_timeout 86400;
    }
`
  }

  if (nginx.api_path && nginx.api_port) {
    sharedServices += `
    # Engine API (shared)
    location ${nginx.api_path} {
        proxy_pass http://127.0.0.1:${nginx.api_port};
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
`
  }

  return `# Generated by Shyp - ${engine.name}/${moduleName}
# Do not edit manually

server {
    listen 80;
    listen [::]:80;
    server_name ${domain}${aliases};

    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${domain}${aliases};

    ssl_certificate /etc/letsencrypt/live/${domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${domain}/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Module frontend
    location / {
        proxy_pass http://127.0.0.1:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
${sharedServices}
    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml+rss application/json application/javascript image/svg+xml;

    access_log /var/log/nginx/${engine.name}-${moduleName}-access.log;
    error_log /var/log/nginx/${engine.name}-${moduleName}-error.log;
}
`
}

// Generate nginx config based on app type
export function generateNginxConfig(config: AppConfig): string {
  if (config.type === 'static') {
    return generateStaticConfig(config)
  }
  return generateProxyConfig(config)
}

// Get nginx config file name
export function getNginxConfigName(name: string): string {
  return `shyp-${name}.conf`
}

// Write nginx config to sites-available
export async function writeNginxConfig(name: string, content: string): Promise<void> {
  const filename = getNginxConfigName(name)
  const path = join(NGINX_AVAILABLE, filename)
  await writeFile(path, content)
}

// Enable nginx config (symlink to sites-enabled)
export async function enableNginxConfig(name: string): Promise<void> {
  const filename = getNginxConfigName(name)
  const availablePath = join(NGINX_AVAILABLE, filename)
  const enabledPath = join(NGINX_ENABLED, filename)

  // Remove existing symlink if present
  if (existsSync(enabledPath)) {
    await unlink(enabledPath)
  }

  await symlink(availablePath, enabledPath)
}

// Disable nginx config
export async function disableNginxConfig(name: string): Promise<void> {
  const filename = getNginxConfigName(name)
  const enabledPath = join(NGINX_ENABLED, filename)

  if (existsSync(enabledPath)) {
    await unlink(enabledPath)
  }
}

// Test nginx configuration
export async function testNginxConfig(): Promise<{ valid: boolean; error?: string }> {
  try {
    await execa('nginx', ['-t'])
    return { valid: true }
  } catch (error: any) {
    return { valid: false, error: error.stderr || error.message }
  }
}

// Reload nginx
export async function reloadNginx(): Promise<void> {
  await execa('systemctl', ['reload', 'nginx'])
}

// Check if nginx is available
export async function isNginxAvailable(): Promise<boolean> {
  try {
    await execa('nginx', ['-v'])
    return true
  } catch {
    return false
  }
}
